import maplibregl from 'maplibre-gl';

var Config = /** @class */ (function () {
    function Config() {
    }
    Config.setup = function (options) {
        if (options === void 0) { options = {}; }
        Config.options = options;
    };
    Config.get = function () {
        return Config.options || {};
    };
    Config.clear = function () {
        Config.options = {};
    };
    Config.defaultOptions = {
        live: false,
        logLevel: 'error',
        host: 'https://api.radar.io',
        version: 'v1',
        debug: false,
    };
    return Config;
}());

var LOG_LEVELS = {
    none: 0,
    error: 1,
    warn: 2,
    info: 3,
    debug: 4,
};
// get the numeric level for logLevel option
var getLevel = function () {
    // disable logging in tests
    if (window && window.RADAR_TEST_ENV) {
        return LOG_LEVELS.none;
    }
    var _a = Config.get(), logLevel = _a.logLevel, debug = _a.debug;
    if (debug) {
        return LOG_LEVELS.debug;
    }
    if (logLevel) {
        return LOG_LEVELS[logLevel];
    }
    return LOG_LEVELS.error; // default to error-level logging if not set
};
var Logger = /** @class */ (function () {
    function Logger() {
    }
    Logger.debug = function (message) {
        if (getLevel() === LOG_LEVELS.debug) {
            console.log("Radar SDK (debug): ".concat(message.trim()));
        }
    };
    Logger.info = function (message) {
        if (getLevel() >= LOG_LEVELS.info) {
            console.log("Radar SDK: ".concat(message.trim()));
        }
    };
    Logger.warn = function (message) {
        if (getLevel() >= LOG_LEVELS.warn) {
            console.warn("Radar SDK: ".concat(message.trim()));
        }
    };
    Logger.error = function (message) {
        if (getLevel() >= LOG_LEVELS.error) {
            console.error("Radar SDK: ".concat(message.trim()));
        }
    };
    return Logger;
}());

var Storage = /** @class */ (function () {
    function Storage() {
    }
    Object.defineProperty(Storage, "USER_ID", {
        // local storage key definitions for identifying track users
        get: function () {
            return 'radar-userId';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Storage, "DEVICE_ID", {
        get: function () {
            return 'radar-deviceId';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Storage, "INSTALL_ID", {
        get: function () {
            return 'radar-installId';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Storage, "SESSION_ID", {
        get: function () {
            return 'radar-sessionId';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Storage, "DESCRIPTION", {
        get: function () {
            return 'radar-description';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Storage, "METADATA", {
        get: function () {
            return 'radar-metadata';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Storage, "CACHED_LOCATION", {
        get: function () {
            return 'radar-cached-location';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Storage, "TRIP_OPTIONS", {
        get: function () {
            return 'radar-trip-options';
        },
        enumerable: false,
        configurable: true
    });
    Storage.getStorage = function () {
        var storage = window === null || window === void 0 ? void 0 : window.localStorage;
        if (!storage) {
            Logger.warn('localStorage not available.');
        }
        return storage;
    };
    Storage.setItem = function (key, value) {
        var storage = this.getStorage();
        if (!storage) {
            return;
        }
        if (value === undefined || value === null) {
            return;
        }
        storage.setItem(key, value);
    };
    Storage.getItem = function (key) {
        var storage = this.getStorage();
        if (!storage) {
            return null;
        }
        var value = storage.getItem(key);
        if (value !== undefined && value !== null) {
            return value;
        }
        return null;
    };
    Storage.getJSON = function (key) {
        var item = this.getItem(key);
        if (!item) {
            return null;
        }
        try {
            return JSON.parse(item);
        }
        catch (err) {
            Logger.warn("could not getJSON from storage for key: ".concat(key));
            return null;
        }
    };
    Storage.removeItem = function (key) {
        var storage = this.getStorage();
        if (!storage) {
            return null;
        }
        storage.removeItem(key);
    };
    Storage.clear = function () {
        var storage = this.getStorage();
        if (!storage) {
            return null;
        }
        storage.clear();
    };
    return Storage;
}());

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var RadarError = /** @class */ (function (_super) {
    __extends(RadarError, _super);
    function RadarError(message) {
        var _this = _super.call(this, message) || this;
        _this.status = ''; // to be overridden (support for legacy status)
        return _this;
    }
    return RadarError;
}(Error));
var RadarPublishableKeyError = /** @class */ (function (_super) {
    __extends(RadarPublishableKeyError, _super);
    function RadarPublishableKeyError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'RadarPublishableKeyError';
        _this.status = 'ERROR_PUBLISHABLE_KEY';
        return _this;
    }
    return RadarPublishableKeyError;
}(RadarError));
var RadarLocationError = /** @class */ (function (_super) {
    __extends(RadarLocationError, _super);
    function RadarLocationError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'RadarLocationError';
        _this.status = 'ERROR_LOCATION';
        return _this;
    }
    return RadarLocationError;
}(RadarError));
var RadarPermissionsError = /** @class */ (function (_super) {
    __extends(RadarPermissionsError, _super);
    function RadarPermissionsError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'RadarPermissionsError';
        _this.status = 'ERROR_PERMISSIONS';
        return _this;
    }
    return RadarPermissionsError;
}(RadarError));
var RadarVerifyAppError = /** @class */ (function (_super) {
    __extends(RadarVerifyAppError, _super);
    function RadarVerifyAppError() {
        var _this = _super.call(this, 'Radar Verify app not running.') || this;
        _this.name = 'RadarVerifyAppError';
        _this.status = 'ERROR_VERIFY_APP';
        return _this;
    }
    return RadarVerifyAppError;
}(RadarError));
// HTTP Errors
var RadarBadRequestError = /** @class */ (function (_super) {
    __extends(RadarBadRequestError, _super);
    function RadarBadRequestError(response) {
        var _this = this;
        var _a;
        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Bad request.') || this;
        _this.name = 'RadarBadRequestError';
        _this.code = 400;
        _this.response = response;
        _this.status = 'ERROR_BAD_REQUEST';
        return _this;
    }
    return RadarBadRequestError;
}(RadarError));
var RadarUnauthorizedError = /** @class */ (function (_super) {
    __extends(RadarUnauthorizedError, _super);
    function RadarUnauthorizedError(response) {
        var _this = this;
        var _a;
        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Unauthorized.') || this;
        _this.name = 'RadarUnauthorizedError';
        _this.code = 401;
        _this.response = response;
        _this.status = 'ERROR_UNAUTHORIZED';
        return _this;
    }
    return RadarUnauthorizedError;
}(RadarError));
var RadarPaymentRequiredError = /** @class */ (function (_super) {
    __extends(RadarPaymentRequiredError, _super);
    function RadarPaymentRequiredError(response) {
        var _this = this;
        var _a;
        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Payment required.') || this;
        _this.name = 'RadarPaymentRequiredError';
        _this.code = 402;
        _this.response = response;
        _this.status = 'ERROR_PAYMENT_REQUIRED';
        return _this;
    }
    return RadarPaymentRequiredError;
}(RadarError));
var RadarForbiddenError = /** @class */ (function (_super) {
    __extends(RadarForbiddenError, _super);
    function RadarForbiddenError(response) {
        var _this = this;
        var _a;
        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Forbidden.') || this;
        _this.name = 'RadarForbiddenError';
        _this.code = 403;
        _this.response = response;
        _this.status = 'ERROR_FORBIDDEN';
        return _this;
    }
    return RadarForbiddenError;
}(RadarError));
var RadarNotFoundError = /** @class */ (function (_super) {
    __extends(RadarNotFoundError, _super);
    function RadarNotFoundError(response) {
        var _this = this;
        var _a;
        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Not found.') || this;
        _this.name = 'RadarNotFoundError';
        _this.code = 404;
        _this.response = response;
        _this.status = 'ERROR_NOT_FOUND';
        return _this;
    }
    return RadarNotFoundError;
}(RadarError));
var RadarRateLimitError = /** @class */ (function (_super) {
    __extends(RadarRateLimitError, _super);
    function RadarRateLimitError(response) {
        var _this = this;
        var _a, _b;
        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Rate limit exceeded.') || this;
        _this.name = 'RadarRateLimitError';
        _this.code = 429;
        _this.response = response;
        _this.type = (_b = response === null || response === void 0 ? void 0 : response.meta) === null || _b === void 0 ? void 0 : _b.type;
        _this.status = 'ERROR_RATE_LIMIT';
        return _this;
    }
    return RadarRateLimitError;
}(RadarError));
var RadarServerError = /** @class */ (function (_super) {
    __extends(RadarServerError, _super);
    function RadarServerError(response) {
        var _this = this;
        var _a;
        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Internal server error.') || this;
        _this.name = 'RadarServerError';
        _this.response = response;
        _this.status = 'ERROR_SERVER';
        return _this;
    }
    return RadarServerError;
}(RadarError));
var RadarNetworkError = /** @class */ (function (_super) {
    __extends(RadarNetworkError, _super);
    function RadarNetworkError() {
        var _this = _super.call(this, 'Request timed out.') || this;
        _this.name = 'RadarNetworkError';
        _this.status = 'ERROR_NETWORK';
        return _this;
    }
    return RadarNetworkError;
}(RadarError));
var RadarUnknownError = /** @class */ (function (_super) {
    __extends(RadarUnknownError, _super);
    function RadarUnknownError(response) {
        var _this = this;
        var _a;
        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Something went wrong.') || this;
        _this.name = 'RadarUnknownError';
        _this.response = response;
        _this.status = 'ERROR_UNKNOWN';
        return _this;
    }
    return RadarUnknownError;
}(RadarError));
var RadarAutocompleteContainerNotFound = /** @class */ (function (_super) {
    __extends(RadarAutocompleteContainerNotFound, _super);
    function RadarAutocompleteContainerNotFound(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'RadarAutocompleteContainerNotFound';
        _this.status = 'CONTAINER_NOT_FOUND';
        return _this;
    }
    return RadarAutocompleteContainerNotFound;
}(RadarError));

var DEFAULT_POSITION_OPTIONS = {
    maximumAge: 0,
    timeout: 1000 * 30,
    enableHighAccuracy: true,
};
// set "enableHighAccuracy" for navigator only when desiredAccuracy is "high"
var useHighAccuracy = function (desiredAccuracy) { return (Boolean(desiredAccuracy === 'high')); };
var Navigator = /** @class */ (function () {
    function Navigator() {
    }
    Navigator.getCurrentPosition = function (overrides) {
        if (overrides === void 0) { overrides = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var options = Config.get();
                        if (!navigator || !navigator.geolocation) {
                            return reject(new RadarLocationError('navigator.geolocation is not available.'));
                        }
                        // use cached location if available and options are set
                        if (options.cacheLocationMinutes) {
                            try {
                                var rawCachedLocation = Storage.getItem(Storage.CACHED_LOCATION);
                                if (rawCachedLocation) {
                                    var cachedLocation = JSON.parse(rawCachedLocation);
                                    var _a = cachedLocation || {}, latitude = _a.latitude, longitude = _a.longitude, accuracy = _a.accuracy, expiresAt = _a.expiresAt;
                                    if (Date.now() < parseInt(expiresAt)) {
                                        if (latitude && longitude && accuracy) {
                                            return resolve({ latitude: latitude, longitude: longitude, accuracy: accuracy });
                                        }
                                    }
                                }
                            }
                            catch (e) {
                                Logger.warn('could not load cached location.');
                            }
                        }
                        // set options from config
                        var positionOptions = Object.assign({}, DEFAULT_POSITION_OPTIONS);
                        if (options.locationMaximumAge !== undefined) {
                            positionOptions.maximumAge = options.locationMaximumAge;
                        }
                        if (options.locationTimeout !== undefined) {
                            positionOptions.timeout = options.locationTimeout;
                        }
                        if (options.desiredAccuracy !== undefined) {
                            positionOptions.enableHighAccuracy = useHighAccuracy(options.desiredAccuracy);
                        }
                        // set options from overrides
                        if (overrides.desiredAccuracy !== undefined) {
                            positionOptions.enableHighAccuracy = useHighAccuracy(overrides.desiredAccuracy);
                        }
                        Logger.info("Using geolocation options: ".concat(JSON.stringify(positionOptions)));
                        // get current location from browser
                        navigator.geolocation.getCurrentPosition(function (position) {
                            if (!position || !position.coords) {
                                return reject(new RadarLocationError('device location return empty coordinates.'));
                            }
                            var _a = position.coords, latitude = _a.latitude, longitude = _a.longitude, accuracy = _a.accuracy;
                            // cache location if option is set
                            if (options.cacheLocationMinutes) {
                                var cacheLocationMinutes = Number.parseFloat(options.cacheLocationMinutes);
                                var updatedAt = Date.now();
                                var expiresAt = updatedAt + (cacheLocationMinutes * 60 * 1000); // convert to ms
                                var lastLocation = { latitude: latitude, longitude: longitude, accuracy: accuracy, updatedAt: updatedAt, expiresAt: expiresAt };
                                Storage.setItem(Storage.CACHED_LOCATION, JSON.stringify(lastLocation));
                            }
                            return resolve({ latitude: latitude, longitude: longitude, accuracy: accuracy });
                        }, function (err) {
                            if (err && err.code === 1) {
                                // https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError
                                // code 1 means location permissions denied
                                // codes 2 and 3 mean location unavailable or timeout
                                return reject(new RadarPermissionsError('Location permissions denied.'));
                            }
                            return reject(new RadarLocationError('Could not determine location.'));
                        }, positionOptions);
                    })];
            });
        });
    };
    Navigator.getPermissionStatus = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (!navigator || !navigator.permissions) {
                            return reject(new RadarLocationError('navigator.permissions is not available.'));
                        }
                        navigator.permissions.query({ name: 'geolocation' }).then(function (permissionsStatus) {
                            var locationAuthorization = 'NOT_DETERMINED';
                            switch (permissionsStatus.state) {
                                case 'granted':
                                    locationAuthorization = 'GRANTED_FOREGROUND';
                                    break;
                                case 'denied':
                                    locationAuthorization = 'DENIED';
                                    break;
                                case 'prompt':
                                    locationAuthorization = 'NOT_DETERMINED';
                                    break;
                            }
                            return resolve(locationAuthorization);
                        });
                    })];
            });
        });
    };
    return Navigator;
}());

var SDK_VERSION = '4.2.1';

var Http = /** @class */ (function () {
    function Http() {
    }
    Http.request = function (_a) {
        var method = _a.method, path = _a.path, data = _a.data, host = _a.host, headers = _a.headers;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var options = Config.get();
                        // check for publishableKey on request
                        var publishableKey = options.publishableKey;
                        if (!publishableKey) {
                            reject(new RadarPublishableKeyError('publishableKey not set.'));
                            return;
                        }
                        // setup request URL
                        var urlHost = host || options.host;
                        var version = options.version;
                        var url = "".concat(urlHost, "/").concat(version, "/").concat(path);
                        // remove undefined values from request data
                        var body = {};
                        Object.keys(data || {}).forEach(function (key) {
                            var value = data[key];
                            if (value !== undefined) {
                                body[key] = value;
                            }
                        });
                        // convert data to querystring for GET requests
                        if (method === 'GET') {
                            var params = Object.keys(body).map(function (key) { return ("".concat(key, "=").concat(encodeURIComponent(body[key]))); });
                            if (params.length > 0) {
                                var queryString = params.join('&');
                                url = "".concat(url, "?").concat(queryString);
                            }
                            body = undefined; // dont send body for GET request
                        }
                        var xhr = new XMLHttpRequest();
                        xhr.open(method, url, true);
                        // set standard headers
                        xhr.setRequestHeader('Authorization', publishableKey);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.setRequestHeader('X-Radar-Device-Type', 'Web');
                        xhr.setRequestHeader('X-Radar-SDK-Version', SDK_VERSION);
                        // set passed custom headers if present
                        if (headers) {
                            Object.keys(headers).forEach(function (key) {
                                var val = headers[key];
                                xhr.setRequestHeader(key, val);
                            });
                        }
                        // set config custom headers if present
                        if (typeof options.getRequestHeaders === 'function') {
                            var headers_1 = options.getRequestHeaders();
                            Object.keys(headers_1 || {}).forEach(function (key) {
                                xhr.setRequestHeader(key, headers_1[key]);
                            });
                        }
                        xhr.onload = function () {
                            var _a;
                            var response;
                            try {
                                response = JSON.parse(xhr.response);
                            }
                            catch (e) {
                                return reject(new RadarServerError(response));
                            }
                            var error = (_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.error;
                            if (error === 'ERROR_PERMISSIONS') {
                                return reject(new RadarPermissionsError('Location permissions not granted.'));
                            }
                            else if (error === 'ERROR_LOCATION') {
                                return reject(new RadarLocationError('Could not determine location.'));
                            }
                            else if (error === 'ERROR_NETWORK') {
                                return reject(new RadarNetworkError());
                            }
                            if (xhr.status == 200) {
                                return resolve(response);
                            }
                            if (options.debug) {
                                Logger.debug("API call failed: ".concat(url));
                                Logger.debug(JSON.stringify(response));
                            }
                            if (xhr.status === 400) {
                                reject(new RadarBadRequestError(response));
                            }
                            else if (xhr.status === 401) {
                                reject(new RadarUnauthorizedError(response));
                            }
                            else if (xhr.status === 402) {
                                reject(new RadarPaymentRequiredError(response));
                            }
                            else if (xhr.status === 403) {
                                reject(new RadarForbiddenError(response));
                            }
                            else if (xhr.status === 404) {
                                reject(new RadarNotFoundError(response));
                            }
                            else if (xhr.status === 429) {
                                reject(new RadarRateLimitError(response));
                            }
                            else if (500 <= xhr.status && xhr.status < 600) {
                                reject(new RadarServerError(response));
                            }
                            else {
                                reject(new RadarUnknownError(response));
                            }
                        };
                        xhr.onerror = function () {
                            if (host && (host === 'http://localhost:52516' || host === 'https://radar-verify.com:52516')) {
                                reject(new RadarVerifyAppError());
                            }
                            else {
                                reject(new RadarServerError());
                            }
                        };
                        xhr.ontimeout = function () {
                            reject(new RadarVerifyAppError());
                        };
                        xhr.send(JSON.stringify(body));
                    })];
            });
        });
    };
    return Http;
}());

var AddressesAPI = /** @class */ (function () {
    function AddressesAPI() {
    }
    AddressesAPI.validateAddress = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, response, address, result, validateAddressRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'addresses/validate',
                                data: params,
                            })];
                    case 1:
                        response = _a.sent();
                        address = response.address, result = response.result;
                        validateAddressRes = {
                            address: address,
                            result: result,
                        };
                        if (options.debug) {
                            validateAddressRes.response = response;
                        }
                        return [2 /*return*/, validateAddressRes];
                }
            });
        });
    };
    return AddressesAPI;
}());

var generateUUID = function () {
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (char) {
        var r = Math.random() * 16 | 0;
        var v = (char == 'x') ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
    return uuid;
};
var Device = /** @class */ (function () {
    function Device() {
    }
    Device.getDeviceId = function () {
        // use existing deviceId if present
        var deviceId = Storage.getItem(Storage.DEVICE_ID);
        if (deviceId) {
            return deviceId;
        }
        // generate new deviceId
        var uuid = generateUUID();
        Storage.setItem(Storage.DEVICE_ID, uuid);
        return uuid;
    };
    Device.getInstallId = function () {
        // use existing installId if present
        var deviceId = Storage.getItem(Storage.INSTALL_ID);
        if (deviceId) {
            return deviceId;
        }
        // generate new installId
        var uuid = generateUUID();
        Storage.setItem(Storage.INSTALL_ID, uuid);
        return uuid;
    };
    return Device;
}());

var SESSION_TIMEOUT_SECS = 300; // 5 mins
var isValid = function (sessionId) {
    var now = Math.trunc(Date.now() / 1000);
    var session = Number.parseInt(sessionId);
    var diff = Math.abs(now - session);
    return diff < SESSION_TIMEOUT_SECS;
};
var Session = /** @class */ (function () {
    function Session() {
    }
    Session.getSessionId = function () {
        var sessionId = Storage.getItem(Storage.SESSION_ID);
        // reuse session if still within 5 min threshold
        if (sessionId && isValid(sessionId)) {
            return sessionId;
        }
        // create new session if does not already exist or expired
        var newSessionId = Math.trunc(Date.now() / 1000).toString(); // unix ts in seconds
        Storage.setItem(Storage.SESSION_ID, newSessionId);
        return newSessionId;
    };
    return Session;
}());

var ConfigAPI = /** @class */ (function () {
    function ConfigAPI() {
    }
    ConfigAPI.getConfig = function (params) {
        if (params === void 0) { params = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var options, deviceId, installId, sessionId, locationAuthorization, data, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        if (options.version != 'v1') {
                            Logger.info('Skipping /config call.');
                            return [2 /*return*/];
                        }
                        deviceId = params.deviceId || Device.getDeviceId();
                        installId = params.installId || Device.getInstallId();
                        sessionId = Session.getSessionId();
                        return [4 /*yield*/, Navigator.getPermissionStatus()];
                    case 1:
                        locationAuthorization = _a.sent();
                        data = {
                            deviceId: deviceId,
                            installId: installId,
                            sessionId: sessionId,
                            locationAuthorization: locationAuthorization,
                        };
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'config',
                                data: data,
                            })];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        err_1 = _a.sent();
                        Logger.warn("Error calling /config: ".concat(err_1.message));
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return ConfigAPI;
}());

var ContextAPI = /** @class */ (function () {
    function ContextAPI() {
    }
    ContextAPI.getContext = function (location) {
        return __awaiter(this, void 0, void 0, function () {
            var options, latitude, longitude, accuracy, response, geofences, place, country, state, dma, postalCode, contextRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        if (!(!location.latitude || !location.longitude)) return [3 /*break*/, 2];
                        return [4 /*yield*/, Navigator.getCurrentPosition()];
                    case 1:
                        location = _a.sent();
                        _a.label = 2;
                    case 2:
                        latitude = location.latitude, longitude = location.longitude, accuracy = location.accuracy;
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'context',
                                data: {
                                    coordinates: "".concat(latitude, ",").concat(longitude),
                                    accuracy: accuracy,
                                },
                            })];
                    case 3:
                        response = _a.sent();
                        geofences = response.geofences, place = response.place, country = response.country, state = response.state, dma = response.dma, postalCode = response.postalCode;
                        contextRes = {
                            location: location,
                            geofences: geofences,
                            place: place,
                            country: country,
                            state: state,
                            dma: dma,
                            postalCode: postalCode,
                        };
                        if (options.debug) {
                            contextRes.response = response;
                        }
                        return [2 /*return*/, contextRes];
                }
            });
        });
    };
    return ContextAPI;
}());

var ConversionsAPI = /** @class */ (function () {
    function ConversionsAPI() {
    }
    ConversionsAPI.logConversion = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, name, userId, deviceId, installId, metadata, createdAt, data, response, conversionRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        name = params.name;
                        userId = params.userId || Storage.getItem(Storage.USER_ID);
                        deviceId = params.deviceId || Device.getDeviceId();
                        installId = params.installId || Device.getInstallId();
                        metadata = params.metadata || {};
                        createdAt = params.createdAt;
                        if (params.revenue) {
                            metadata.revenue = params.revenue;
                        }
                        data = {
                            name: name,
                            userId: userId,
                            deviceId: deviceId,
                            installId: installId,
                            metadata: metadata,
                        };
                        if (typeof createdAt === 'string') {
                            data.createdAt = createdAt;
                        }
                        else if (createdAt instanceof Date) {
                            data.createdAt = createdAt.toISOString();
                        }
                        else {
                            data.createdAt = (new Date()).toISOString();
                        }
                        return [4 /*yield*/, Http.request({
                                method: 'POST',
                                path: 'events',
                                data: data,
                            })];
                    case 1:
                        response = _a.sent();
                        conversionRes = {
                            event: response.event,
                        };
                        if (options.debug) {
                            conversionRes.response = response;
                        }
                        return [2 /*return*/, conversionRes];
                }
            });
        });
    };
    return ConversionsAPI;
}());

var Geocoding = /** @class */ (function () {
    function Geocoding() {
    }
    Geocoding.forwardGeocode = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, query, layers, country, response, forwardGeocodeRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        query = params.query, layers = params.layers, country = params.country;
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'geocode/forward',
                                data: {
                                    query: query,
                                    layers: layers,
                                    country: country,
                                },
                            })];
                    case 1:
                        response = _a.sent();
                        forwardGeocodeRes = {
                            addresses: response.addresses,
                        };
                        if (options.debug) {
                            forwardGeocodeRes.response = response;
                        }
                        return [2 /*return*/, forwardGeocodeRes];
                }
            });
        });
    };
    Geocoding.reverseGeocode = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, latitude, longitude, layers, location_1, response, reverseGeocodeRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        latitude = params.latitude, longitude = params.longitude, layers = params.layers;
                        if (!(!latitude || !longitude)) return [3 /*break*/, 2];
                        return [4 /*yield*/, Navigator.getCurrentPosition()];
                    case 1:
                        location_1 = _a.sent();
                        latitude = location_1.latitude;
                        longitude = location_1.longitude;
                        _a.label = 2;
                    case 2: return [4 /*yield*/, Http.request({
                            method: 'GET',
                            path: 'geocode/reverse',
                            data: {
                                coordinates: "".concat(latitude, ",").concat(longitude),
                                layers: layers,
                            },
                        })];
                    case 3:
                        response = _a.sent();
                        reverseGeocodeRes = {
                            addresses: response.addresses,
                        };
                        if (options.debug) {
                            reverseGeocodeRes.response = response;
                        }
                        return [2 /*return*/, reverseGeocodeRes];
                }
            });
        });
    };
    Geocoding.ipGeocode = function () {
        return __awaiter(this, void 0, void 0, function () {
            var options, response, ipGeocodeRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'geocode/ip',
                            })];
                    case 1:
                        response = _a.sent();
                        ipGeocodeRes = {
                            ip: response.ip,
                            address: response.address,
                            proxy: response.proxy,
                        };
                        if (options.debug) {
                            ipGeocodeRes.response = response;
                        }
                        return [2 /*return*/, ipGeocodeRes];
                }
            });
        });
    };
    return Geocoding;
}());

var RoutingAPI = /** @class */ (function () {
    function RoutingAPI() {
    }
    RoutingAPI.distance = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, origin, destination, modes, units, geometry, geometryPoints, avoid, _a, latitude, longitude, latitude, longitude, latitude, longitude, response, distanceRes;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options = Config.get();
                        origin = params.origin, destination = params.destination, modes = params.modes, units = params.units, geometry = params.geometry, geometryPoints = params.geometryPoints, avoid = params.avoid;
                        if (!!origin) return [3 /*break*/, 2];
                        return [4 /*yield*/, Navigator.getCurrentPosition()];
                    case 1:
                        _a = _b.sent(), latitude = _a.latitude, longitude = _a.longitude;
                        origin = "".concat(latitude, ",").concat(longitude);
                        return [3 /*break*/, 3];
                    case 2:
                        if (typeof origin !== 'string') { // origin is "Location" object
                            latitude = origin.latitude, longitude = origin.longitude;
                            origin = "".concat(latitude, ",").concat(longitude);
                        }
                        _b.label = 3;
                    case 3:
                        if (typeof destination !== 'string') {
                            latitude = destination.latitude, longitude = destination.longitude;
                            destination = "".concat(latitude, ",").concat(longitude);
                        }
                        if (Array.isArray(modes)) {
                            modes = modes.join(',');
                        }
                        if (Array.isArray(avoid)) {
                            avoid = avoid.join(',');
                        }
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'route/distance',
                                data: {
                                    origin: origin,
                                    destination: destination,
                                    modes: modes,
                                    units: units,
                                    geometry: geometry,
                                    geometryPoints: geometryPoints,
                                    avoid: avoid,
                                },
                            })];
                    case 4:
                        response = _b.sent();
                        distanceRes = {
                            routes: response.routes,
                        };
                        if (options.debug) {
                            distanceRes.response = response;
                        }
                        return [2 /*return*/, distanceRes];
                }
            });
        });
    };
    RoutingAPI.matrix = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, origins, destinations, mode, units, avoid, _a, latitude, longitude, originStrings, i, response, matrixRes;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options = Config.get();
                        origins = params.origins, destinations = params.destinations, mode = params.mode, units = params.units, avoid = params.avoid;
                        if (!!origins) return [3 /*break*/, 2];
                        return [4 /*yield*/, Navigator.getCurrentPosition()];
                    case 1:
                        _a = _b.sent(), latitude = _a.latitude, longitude = _a.longitude;
                        originStrings = [];
                        for (i = 0; i < destinations.length; i++) {
                            originStrings.push("".concat(latitude, ",").concat(longitude));
                        }
                        origins = originStrings.join('|');
                        return [3 /*break*/, 3];
                    case 2:
                        if (Array.isArray(origins)) { // origin is a list of "Location" objects
                            origins = origins.map(function (location) { return "".concat(location.latitude, ",").concat(location.longitude); }).join('|');
                        }
                        _b.label = 3;
                    case 3:
                        // convert array to pipe-delimited string
                        if (Array.isArray(destinations)) {
                            destinations = destinations.map(function (location) { return "".concat(location.latitude, ",").concat(location.longitude); }).join('|');
                        }
                        if (Array.isArray(avoid)) {
                            avoid = avoid.join(',');
                        }
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'route/matrix',
                                data: {
                                    origins: origins,
                                    destinations: destinations,
                                    mode: mode,
                                    units: units,
                                    avoid: avoid,
                                },
                            })];
                    case 4:
                        response = _b.sent();
                        matrixRes = {
                            origins: response.origins,
                            destinations: response.destinations,
                            matrix: response.matrix,
                        };
                        if (options.debug) {
                            matrixRes.response = response;
                        }
                        return [2 /*return*/, matrixRes];
                }
            });
        });
    };
    return RoutingAPI;
}());

var SearchAPI = /** @class */ (function () {
    function SearchAPI() {
    }
    SearchAPI.autocomplete = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, query, near, limit, layers, countryCode, expandUnits, mailable, response, autocompleteRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        query = params.query, near = params.near, limit = params.limit, layers = params.layers, countryCode = params.countryCode, expandUnits = params.expandUnits, mailable = params.mailable;
                        // near can be provided as a string or Location object
                        // if "near" is not provided, request will fallback to IP based location
                        if (near && typeof near !== 'string') {
                            if (near.latitude && near.longitude) {
                                near = "".concat(near.latitude, ",").concat(near.longitude);
                            }
                        }
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'search/autocomplete',
                                data: {
                                    query: query,
                                    near: near,
                                    limit: limit,
                                    layers: layers,
                                    countryCode: countryCode,
                                    expandUnits: expandUnits,
                                    mailable: mailable,
                                },
                            })];
                    case 1:
                        response = _a.sent();
                        autocompleteRes = {
                            addresses: response.addresses,
                        };
                        if (options.debug) {
                            autocompleteRes.response = response;
                        }
                        return [2 /*return*/, autocompleteRes];
                }
            });
        });
    };
    SearchAPI.searchGeofences = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, near, radius, tags, metadata, limit, includeGeometry, _a, latitude, longitude, latitude, longitude, response, geofencesSearchRes;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options = Config.get();
                        near = params.near, radius = params.radius, tags = params.tags, metadata = params.metadata, limit = params.limit, includeGeometry = params.includeGeometry;
                        if (!!near) return [3 /*break*/, 2];
                        return [4 /*yield*/, Navigator.getCurrentPosition()];
                    case 1:
                        _a = _b.sent(), latitude = _a.latitude, longitude = _a.longitude;
                        near = "".concat(latitude, ",").concat(longitude);
                        return [3 /*break*/, 3];
                    case 2:
                        if (typeof near !== 'string') { // near is "Location" object
                            latitude = near.latitude, longitude = near.longitude;
                            near = "".concat(latitude, ",").concat(longitude);
                        }
                        _b.label = 3;
                    case 3:
                        // convert arrays to comma-strings
                        if (Array.isArray(tags)) {
                            tags = tags.join(',');
                        }
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'search/geofences',
                                data: {
                                    near: near,
                                    radius: radius,
                                    tags: tags,
                                    metadata: metadata,
                                    limit: limit,
                                    includeGeometry: includeGeometry,
                                },
                            })];
                    case 4:
                        response = _b.sent();
                        geofencesSearchRes = {
                            geofences: response.geofences,
                        };
                        if (options.debug) {
                            geofencesSearchRes.response = response;
                        }
                        return [2 /*return*/, geofencesSearchRes];
                }
            });
        });
    };
    SearchAPI.searchPlaces = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var options, near, radius, chains, categories, groups, limit, _a, latitude, longitude, latitude, longitude, response, placeSearchRes;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options = Config.get();
                        near = params.near, radius = params.radius, chains = params.chains, categories = params.categories, groups = params.groups, limit = params.limit;
                        if (!!near) return [3 /*break*/, 2];
                        return [4 /*yield*/, Navigator.getCurrentPosition()];
                    case 1:
                        _a = _b.sent(), latitude = _a.latitude, longitude = _a.longitude;
                        near = "".concat(latitude, ",").concat(longitude);
                        return [3 /*break*/, 3];
                    case 2:
                        if (typeof near !== 'string') { // near is "Location" object
                            latitude = near.latitude, longitude = near.longitude;
                            near = "".concat(latitude, ",").concat(longitude);
                        }
                        _b.label = 3;
                    case 3:
                        // convert arrays to comma-strings
                        if (Array.isArray(chains)) {
                            chains = chains.join(',');
                        }
                        if (Array.isArray(categories)) {
                            categories = categories.join(',');
                        }
                        if (Array.isArray(groups)) {
                            groups = groups.join(',');
                        }
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'search/places',
                                data: {
                                    near: near,
                                    radius: radius,
                                    chains: chains,
                                    categories: categories,
                                    groups: groups,
                                    limit: limit,
                                },
                            })];
                    case 4:
                        response = _b.sent();
                        placeSearchRes = {
                            places: response.places,
                        };
                        if (options.debug) {
                            placeSearchRes.response = response;
                        }
                        return [2 /*return*/, placeSearchRes];
                }
            });
        });
    };
    return SearchAPI;
}());

// https://stackoverflow.com/a/44198641
var isValidDate = function (date) { return date && Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date); };
var TripsAPI = /** @class */ (function () {
    function TripsAPI() {
    }
    TripsAPI.setTripOptions = function (tripOptions) {
        if (!tripOptions) {
            TripsAPI.clearTripOptions();
            return;
        }
        var tripOptionsString = JSON.stringify(tripOptions);
        Logger.debug("Saving trip options: ".concat(tripOptionsString));
        Storage.setItem(Storage.TRIP_OPTIONS, tripOptionsString);
    };
    TripsAPI.getTripOptions = function () {
        var tripOptions = Storage.getItem(Storage.TRIP_OPTIONS);
        if (tripOptions) {
            tripOptions = JSON.parse(tripOptions);
        }
        return tripOptions;
    };
    TripsAPI.clearTripOptions = function () {
        Storage.removeItem(Storage.TRIP_OPTIONS);
    };
    TripsAPI.startTrip = function (tripOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var options, userId, externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, data, response, tripRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        tripOptions = tripOptions || TripsAPI.getTripOptions();
                        if (!tripOptions) {
                            Logger.warn('tripOptions not set when calling "startTrip"');
                        }
                        userId = tripOptions.userId || Storage.getItem(Storage.USER_ID);
                        if (userId && userId !== Storage.getItem(Storage.USER_ID)) {
                            // set as userId for tracking if provided
                            Storage.setItem(Storage.USER_ID, userId);
                        }
                        externalId = tripOptions.externalId, destinationGeofenceTag = tripOptions.destinationGeofenceTag, destinationGeofenceExternalId = tripOptions.destinationGeofenceExternalId, mode = tripOptions.mode, metadata = tripOptions.metadata, approachingThreshold = tripOptions.approachingThreshold, scheduledArrivalAt = tripOptions.scheduledArrivalAt;
                        data = {
                            userId: userId,
                            externalId: externalId,
                            destinationGeofenceTag: destinationGeofenceTag,
                            destinationGeofenceExternalId: destinationGeofenceExternalId,
                            mode: mode,
                            metadata: metadata,
                            approachingThreshold: approachingThreshold,
                        };
                        if (isValidDate(scheduledArrivalAt)) {
                            data.scheduledArrivalAt = scheduledArrivalAt === null || scheduledArrivalAt === void 0 ? void 0 : scheduledArrivalAt.toJSON();
                        }
                        else {
                            if (scheduledArrivalAt) {
                                Logger.warn('Invalid date format for scheduledArrivalAt');
                            }
                            data.scheduledArrivalAt = undefined;
                        }
                        return [4 /*yield*/, Http.request({
                                method: 'POST',
                                path: 'trips',
                                data: data,
                            })];
                    case 1:
                        response = _a.sent();
                        // save trip options
                        TripsAPI.setTripOptions(tripOptions);
                        tripRes = {
                            trip: response.trip,
                            events: response.events,
                        };
                        if (options.debug) {
                            tripRes.response = response;
                        }
                        return [2 /*return*/, tripRes];
                }
            });
        });
    };
    TripsAPI.updateTrip = function (tripOptions, status) {
        return __awaiter(this, void 0, void 0, function () {
            var options, externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, data, response, tripRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = Config.get();
                        tripOptions = tripOptions || TripsAPI.getTripOptions();
                        if (!tripOptions) {
                            Logger.warn('tripOptions not set when calling "startTrip"');
                        }
                        externalId = tripOptions.externalId, destinationGeofenceTag = tripOptions.destinationGeofenceTag, destinationGeofenceExternalId = tripOptions.destinationGeofenceExternalId, mode = tripOptions.mode, metadata = tripOptions.metadata, approachingThreshold = tripOptions.approachingThreshold, scheduledArrivalAt = tripOptions.scheduledArrivalAt;
                        data = {
                            status: status,
                            externalId: externalId,
                            destinationGeofenceTag: destinationGeofenceTag,
                            destinationGeofenceExternalId: destinationGeofenceExternalId,
                            mode: mode,
                            metadata: metadata,
                            approachingThreshold: approachingThreshold,
                        };
                        if (isValidDate(scheduledArrivalAt)) {
                            data.scheduledArrivalAt = scheduledArrivalAt === null || scheduledArrivalAt === void 0 ? void 0 : scheduledArrivalAt.toJSON();
                        }
                        else {
                            if (scheduledArrivalAt) {
                                Logger.warn('Invalid date format for scheduledArrivalAt');
                            }
                            data.scheduledArrivalAt = undefined;
                        }
                        return [4 /*yield*/, Http.request({
                                method: 'PATCH',
                                path: "trips/".concat(externalId, "/update"),
                                data: data,
                            })];
                    case 1:
                        response = _a.sent();
                        tripRes = {
                            trip: response.trip,
                            events: response.events,
                        };
                        if (options.debug) {
                            tripRes.response = response;
                        }
                        return [2 /*return*/, tripRes];
                }
            });
        });
    };
    TripsAPI.completeTrip = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tripOptions, tripResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tripOptions = TripsAPI.getTripOptions();
                        return [4 /*yield*/, TripsAPI.updateTrip(tripOptions, 'completed')];
                    case 1:
                        tripResponse = _a.sent();
                        // clear local trip options
                        TripsAPI.clearTripOptions();
                        return [2 /*return*/, tripResponse];
                }
            });
        });
    };
    TripsAPI.cancelTrip = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tripOptions, tripResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tripOptions = TripsAPI.getTripOptions();
                        return [4 /*yield*/, TripsAPI.updateTrip(tripOptions, 'canceled')];
                    case 1:
                        tripResponse = _a.sent();
                        // clear local trip options
                        TripsAPI.clearTripOptions();
                        return [2 /*return*/, tripResponse];
                }
            });
        });
    };
    return TripsAPI;
}());

var base64Encode = function (str) {
    return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
};
var signJWT = function (payload, key) { return __awaiter(void 0, void 0, void 0, function () {
    var encoder, encodedHeader, encodedPayload, keyData, messageData, cryptoKey, signatureArrayBuffer, signature;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                encoder = new TextEncoder();
                encodedHeader = base64Encode(JSON.stringify({
                    alg: 'HS256',
                    typ: 'JWT',
                }));
                encodedPayload = base64Encode(JSON.stringify(payload));
                keyData = encoder.encode(key);
                messageData = encoder.encode("".concat(encodedHeader, ".").concat(encodedPayload));
                return [4 /*yield*/, crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign'])];
            case 1:
                cryptoKey = _a.sent();
                return [4 /*yield*/, crypto.subtle.sign('HMAC', cryptoKey, messageData)];
            case 2:
                signatureArrayBuffer = _a.sent();
                signature = base64Encode(String.fromCharCode.apply(String, Array.from(new Uint8Array(signatureArrayBuffer))));
                return [2 /*return*/, "".concat(encodedHeader, ".").concat(encodedPayload, ".").concat(signature)];
        }
    });
}); };

var ping = function (host) {
    return new Promise(function (resolve) {
        var socket = new WebSocket(host);
        var pings = 0;
        var latencies = [];
        var pingInterval;
        var timeoutInterval;
        var ping = function () {
            pings++;
            var start = Date.now();
            socket.send('ping');
            socket.onmessage = function (event) {
                if (event.data === 'pong') {
                    var latency = Date.now() - start;
                    latencies.push(latency);
                    if (pings >= 3) {
                        clearInterval(pingInterval);
                        clearInterval(timeoutInterval);
                        var median = latencies.sort(function (a, b) { return a - b; })[1];
                        socket.close();
                        resolve(median);
                    }
                }
            };
        };
        var timeout = function () {
            Logger.warn('Socket timeout');
            clearInterval(pingInterval);
            clearInterval(timeoutInterval);
            socket.close();
            resolve(-1);
        };
        socket.onerror = function (err) {
            Logger.warn('Error opening socket');
            socket.close();
            resolve(-1);
        };
        socket.onopen = function () {
            ping();
            pingInterval = setInterval(ping, 1000);
            timeoutInterval = setInterval(timeout, 10000);
        };
    });
};

var TrackAPI = /** @class */ (function () {
    function TrackAPI() {
    }
    TrackAPI.trackOnce = function (params) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var options, latitude, longitude, accuracy, desiredAccuracy, fraud, deviceLocation, locationAuthorization, err_1, userId, deviceId, installId, sessionId, deviceType, description, timeZone, metadata, tripOptions, body, response, host, pingHost, lang, langs, dk, sclVal, cslVal, _d, sclRes, csl, scl, payload, reqToken, user_1, events_1, token, expiresAt, location_1, passed, expiresIn, trackRes_1, user, events, location, trackRes;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        options = Config.get();
                        latitude = params.latitude, longitude = params.longitude, accuracy = params.accuracy, desiredAccuracy = params.desiredAccuracy, fraud = params.fraud;
                        if (!(!latitude || !longitude)) return [3 /*break*/, 2];
                        return [4 /*yield*/, Navigator.getCurrentPosition({ desiredAccuracy: desiredAccuracy })];
                    case 1:
                        deviceLocation = _e.sent();
                        latitude = deviceLocation.latitude;
                        longitude = deviceLocation.longitude;
                        accuracy = deviceLocation.accuracy;
                        _e.label = 2;
                    case 2:
                        _e.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, Navigator.getPermissionStatus()];
                    case 3:
                        locationAuthorization = _e.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        err_1 = _e.sent();
                        Logger.warn("Location authorization error: ".concat(err_1.message));
                        return [3 /*break*/, 5];
                    case 5:
                        userId = params.userId || Storage.getItem(Storage.USER_ID);
                        deviceId = params.deviceId || Device.getDeviceId();
                        installId = params.installId || Device.getInstallId();
                        sessionId = Session.getSessionId();
                        deviceType = params.deviceType || 'Web';
                        description = params.description || Storage.getItem(Storage.DESCRIPTION);
                        try {
                            timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                        }
                        catch (err) {
                            Logger.warn("Error getting time zone: ".concat(err.message));
                        }
                        // save userId for trip tracking
                        if (!userId) {
                            Logger.warn('userId not provided for trackOnce.');
                        }
                        else {
                            Storage.setItem(Storage.USER_ID, userId);
                        }
                        metadata = params.metadata || Storage.getJSON(Storage.METADATA);
                        tripOptions = params.tripOptions || TripsAPI.getTripOptions();
                        if (tripOptions) {
                            tripOptions.version = '2';
                        }
                        body = __assign(__assign({}, params), { locationAuthorization: locationAuthorization, accuracy: accuracy, description: description, deviceId: deviceId, deviceType: deviceType, foreground: true, installId: installId, sessionId: sessionId, latitude: latitude, longitude: longitude, metadata: metadata, sdkVersion: SDK_VERSION, stopped: true, userId: userId, tripOptions: tripOptions, timeZone: timeZone });
                        if (!fraud) return [3 /*break*/, 13];
                        host = 'https://api-verified.radar.io';
                        pingHost = 'ping.radar-verify.com';
                        lang = navigator.language;
                        langs = navigator.languages;
                        return [4 /*yield*/, Http.request({
                                host: host,
                                method: 'GET',
                                path: 'config',
                                data: {
                                    deviceId: deviceId,
                                    installId: installId,
                                    sessionId: sessionId,
                                    locationAuthorization: locationAuthorization,
                                },
                                headers: {
                                    'X-Radar-Desktop-Device-Type': 'Web',
                                },
                            })];
                    case 6:
                        dk = (_e.sent()).dk;
                        sclVal = -1;
                        cslVal = -1;
                        _e.label = 7;
                    case 7:
                        _e.trys.push([7, 9, , 10]);
                        return [4 /*yield*/, Promise.all([
                                Http.request({
                                    host: "https://".concat(pingHost),
                                    method: 'GET',
                                    path: 'ping',
                                }),
                                ping("wss://".concat(pingHost)),
                            ])];
                    case 8:
                        _d = _e.sent(), sclRes = _d[0], csl = _d[1];
                        scl = sclRes.scl;
                        sclVal = scl;
                        cslVal = csl;
                        return [3 /*break*/, 10];
                    case 9:
                        _e.sent();
                        return [3 /*break*/, 10];
                    case 10:
                        payload = {
                            payload: JSON.stringify(__assign(__assign({}, body), { scl: sclVal, csl: cslVal, lang: lang, langs: langs })),
                        };
                        return [4 /*yield*/, signJWT(payload, dk)];
                    case 11:
                        reqToken = _e.sent();
                        return [4 /*yield*/, Http.request({
                                host: host,
                                method: 'POST',
                                path: 'track',
                                data: {
                                    token: reqToken,
                                },
                                headers: {
                                    'X-Radar-Body-Is-Token': 'true',
                                },
                            })];
                    case 12:
                        response = _e.sent();
                        if (options.debug && response && response.user) {
                            if (!response.user.metadata) {
                                response.user.metadata = {};
                            }
                            response.user.metadata['radar:debug'] = {
                                sclVal: sclVal,
                                cslVal: cslVal,
                            };
                        }
                        user_1 = response.user, events_1 = response.events, token = response.token, expiresAt = response.expiresAt;
                        location_1 = { latitude: latitude, longitude: longitude, accuracy: accuracy };
                        passed = void 0;
                        expiresIn = void 0;
                        if (expiresAt) {
                            expiresAt = new Date(expiresAt);
                            passed = ((_a = user_1 === null || user_1 === void 0 ? void 0 : user_1.fraud) === null || _a === void 0 ? void 0 : _a.passed) && ((_b = user_1 === null || user_1 === void 0 ? void 0 : user_1.country) === null || _b === void 0 ? void 0 : _b.passed) && ((_c = user_1 === null || user_1 === void 0 ? void 0 : user_1.state) === null || _c === void 0 ? void 0 : _c.passed);
                            expiresIn = (expiresAt.getTime() - Date.now()) / 1000;
                        }
                        trackRes_1 = {
                            user: user_1,
                            events: events_1,
                            location: location_1,
                            token: token,
                            expiresAt: expiresAt,
                            expiresIn: expiresIn,
                            passed: passed,
                        };
                        if (options.debug) {
                            trackRes_1.response = response;
                        }
                        return [2 /*return*/, trackRes_1];
                    case 13: return [4 /*yield*/, Http.request({
                            method: 'POST',
                            path: 'track',
                            data: body,
                        })];
                    case 14:
                        response = _e.sent();
                        user = response.user, events = response.events;
                        location = { latitude: latitude, longitude: longitude, accuracy: accuracy };
                        trackRes = {
                            user: user,
                            events: events,
                            location: location,
                        };
                        if (options.debug) {
                            trackRes.response = response;
                        }
                        return [2 /*return*/, trackRes];
                }
            });
        });
    };
    return TrackAPI;
}());

var VerifyAPI = /** @class */ (function () {
    function VerifyAPI() {
    }
    VerifyAPI.trackVerified = function (params, encrypted) {
        var _a, _b, _c;
        if (encrypted === void 0) { encrypted = false; }
        return __awaiter(this, void 0, void 0, function () {
            var options, userId, deviceId, installId, sessionId, description, metadata, body, userAgent, apple, response, user, events, token, expiresAt, location, passed, expiresIn, trackRes;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        options = Config.get();
                        userId = params.userId || Storage.getItem(Storage.USER_ID);
                        deviceId = params.deviceId || Device.getDeviceId();
                        installId = params.installId || Device.getInstallId();
                        sessionId = Session.getSessionId();
                        description = params.description || Storage.getItem(Storage.DESCRIPTION);
                        // save userId
                        if (!userId) {
                            Logger.warn('userId not provided for trackVerified.');
                        }
                        else {
                            Storage.setItem(Storage.USER_ID, userId);
                        }
                        metadata = params.metadata || Storage.getJSON(Storage.METADATA);
                        body = __assign(__assign({}, params), { description: description, deviceId: deviceId, foreground: true, installId: installId, sessionId: sessionId, metadata: metadata, sdkVersion: SDK_VERSION, stopped: true, userId: userId, encrypted: encrypted });
                        userAgent = navigator.userAgent;
                        apple = userAgent && (userAgent.toLowerCase().includes('mac') || userAgent.toLowerCase().includes('iphone') || userAgent.toLowerCase().includes('ipod') || userAgent.toLowerCase().includes('ipad'));
                        return [4 /*yield*/, Http.request({
                                method: 'GET',
                                path: 'verify',
                                data: body,
                                host: apple ? 'https://radar-verify.com:52516' : 'http://localhost:52516',
                            })];
                    case 1:
                        response = _d.sent();
                        user = response.user, events = response.events, token = response.token, expiresAt = response.expiresAt;
                        if (user && user.location && user.location.coordinates && user.locationAccuracy) {
                            location = {
                                latitude: user.location.coordinates[1],
                                longitude: user.location.coordinates[0],
                                accuracy: user.locationAccuracy,
                            };
                        }
                        if (expiresAt) {
                            expiresAt = new Date(expiresAt);
                            passed = ((_a = user === null || user === void 0 ? void 0 : user.fraud) === null || _a === void 0 ? void 0 : _a.passed) && ((_b = user === null || user === void 0 ? void 0 : user.country) === null || _b === void 0 ? void 0 : _b.passed) && ((_c = user === null || user === void 0 ? void 0 : user.state) === null || _c === void 0 ? void 0 : _c.passed);
                            expiresIn = (expiresAt.getTime() - Date.now()) / 1000;
                        }
                        trackRes = {
                            user: user,
                            events: events,
                            location: location,
                            token: token,
                            expiresAt: expiresAt,
                            expiresIn: expiresIn,
                            passed: passed,
                        };
                        if (options.debug) {
                            trackRes.response = response;
                        }
                        return [2 /*return*/, trackRes];
                }
            });
        });
    };
    return VerifyAPI;
}());

var DEFAULT_STYLE = 'radar-default-v1';
var RADAR_STYLES = [
    'radar-default-v1',
    'radar-light-v1',
    'radar-dark-v1',
];
var RADAR_LOGO_URL = 'https://api.radar.io/maps/static/images/logo.svg';
var defaultMaplibreOptions = {
    minZoom: 1,
    maxZoom: 20,
    attributionControl: false,
    dragRotate: false,
    touchPitch: false,
    maplibreLogo: false,
};
var defaultMarkerOptions = {
    color: '#000257',
};
var createStyleURL = function (options, style) {
    if (style === void 0) { style = DEFAULT_STYLE; }
    return ("".concat(options.host, "/maps/styles/").concat(style, "?publishableKey=").concat(options.publishableKey));
};
// use formatted style URL if using one of Radar's out-of-the-box styles
var getStyle = function (options, mapOptions) {
    var style = mapOptions.style;
    if (!style || (typeof style === 'string' && RADAR_STYLES.includes(style))) {
        return createStyleURL(options, mapOptions.style);
    }
    return mapOptions.style;
};
var MapUI = /** @class */ (function () {
    function MapUI() {
    }
    MapUI.getMapLibre = function () {
        return maplibregl;
    };
    MapUI.createMap = function (mapOptions) {
        var options = Config.get();
        if (!options.publishableKey) {
            Logger.warn('publishableKey not set. Call Radar.initialize() with key before creating a new map.');
        }
        // configure maplibre options
        var style = getStyle(options, mapOptions);
        var maplibreOptions = Object.assign({}, defaultMaplibreOptions, mapOptions, { style: style });
        Logger.debug("initialize map with options: ".concat(JSON.stringify(maplibreOptions)));
        // set container
        maplibreOptions.container = mapOptions.container;
        // custom request handler for Radar styles
        maplibreOptions.transformRequest = function (url, resourceType) {
            if (resourceType === 'Style' && RADAR_STYLES.includes(url)) {
                var radarStyleURL = createStyleURL(options, url);
                return { url: radarStyleURL };
            }
            else {
                return { url: url };
            }
        };
        // create map
        var map = new maplibregl.Map(maplibreOptions);
        var container = map.getContainer();
        if (!container.style.width && !container.style.height) {
            Logger.warn('map container does not have a set "width" or "height"');
        }
        // add radar logo
        var img = document.createElement('img');
        img.src = RADAR_LOGO_URL;
        var link = document.createElement('a');
        link.id = 'radar-map-logo';
        link.href = 'https://radar.com?ref=powered_by_radar';
        link.target = '_blank';
        link.style.position = 'absolute';
        link.style.bottom = '0';
        link.style.left = '5px';
        link.style.width = '80px';
        link.style.height = '38px';
        link.appendChild(img);
        map.getContainer().appendChild(link);
        // add attribution
        var attribution = new maplibregl.AttributionControl({ compact: false });
        map.addControl(attribution, 'bottom-right');
        // add zoom controls
        var nav = new maplibregl.NavigationControl({ showCompass: false });
        map.addControl(nav, 'bottom-right');
        // handle map resize actions
        var onResize = function () {
            var attrib = document.querySelector('.maplibregl-ctrl-attrib');
            if (attrib) {
                var width = map.getContainer().clientWidth;
                if (width < 380) {
                    attrib.classList.add('hidden');
                }
                else {
                    attrib.classList.remove('hidden');
                }
            }
        };
        map.on('resize', onResize);
        map.on('load', onResize);
        return map;
    };
    MapUI.createMarker = function (markerOptions) {
        if (markerOptions === void 0) { markerOptions = {}; }
        var maplibreOptions = Object.assign({}, defaultMarkerOptions);
        if (markerOptions.color) {
            maplibreOptions.color = markerOptions.color;
        }
        if (markerOptions.element) {
            maplibreOptions.element = markerOptions.element;
        }
        if (markerOptions.scale) {
            maplibreOptions.scale = markerOptions.scale;
        }
        var marker = new maplibregl.Marker(maplibreOptions);
        // set popup text or HTML
        if (markerOptions.text) {
            var popup = new maplibregl.Popup({ offset: 35 }).setText(markerOptions.text);
            marker.setPopup(popup);
        }
        else if (markerOptions.html) {
            var popup = new maplibregl.Popup({ offset: 35 }).setHTML(markerOptions.html);
            marker.setPopup(popup);
        }
        return marker;
    };
    return MapUI;
}());

var CLASSNAMES = {
    WRAPPER: 'radar-autocomplete-wrapper',
    INPUT: 'radar-autocomplete-input',
    SEARCH_ICON: 'radar-autocomplete-search-icon',
    RESULTS_LIST: 'radar-autocomplete-results-list',
    RESULTS_ITEM: 'radar-autocomplete-results-item',
    RESULTS_MARKER: 'radar-autocomplete-results-marker',
    SELECTED_ITEM: 'radar-autocomplete-results-item-selected',
    POWERED_BY_RADAR: 'radar-powered',
    NO_RESULTS: 'radar-no-results',
};
var ARIA = {
    EXPANDED: 'aria-expanded',
};
var defaultAutocompleteOptions = {
    container: 'autocomplete',
    debounceMS: 200,
    minCharacters: 3,
    limit: 8,
    placeholder: 'Search address',
    responsive: true,
    disabled: false,
    showMarkers: true,
    hideResultsOnBlur: true,
};
// determine whether to use px or CSS string
var formatCSSValue = function (value) {
    if (typeof value === 'number') {
        return "".concat(value, "px");
    }
    return value;
};
var DEFAULT_WIDTH = 400;
var setWidth = function (input, options) {
    // if responsive and width is provided, treat it as maxWidth
    if (options.responsive) {
        input.style.width = '100%';
        if (options.width) {
            input.style.maxWidth = formatCSSValue(options.width);
        }
        return;
    }
    // if not responsive, set fixed width and unset maxWidth
    input.style.width = formatCSSValue(options.width || DEFAULT_WIDTH);
    input.style.removeProperty('max-width');
};
var setHeight = function (resultsList, options) {
    if (options.maxHeight) {
        resultsList.style.maxHeight = formatCSSValue(options.maxHeight);
        resultsList.style.overflowY = 'auto'; /* allow overflow when maxHeight is applied */
    }
};
var getMarkerIcon = function (color) {
    if (color === void 0) { color = "#ACBDC8"; }
    var fill = color.replace('#', '%23');
    var svg = "<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M12.5704 6.57036C12.5704 4.11632 10.6342 2.11257 8.21016 2C8.14262 2 8.06757 2 8.00003 2C7.93249 2 7.85744 2 7.7899 2C5.35838 2.11257 3.42967 4.11632 3.42967 6.57036C3.42967 6.60037 3.42967 6.6379 3.42967 6.66792C3.42967 6.69794 3.42967 6.73546 3.42967 6.76548C3.42967 9.46717 7.09196 13.3621 7.4672 13.7598C7.61729 13.9174 7.84994 14 8.00003 14C8.15012 14 8.38277 13.9174 8.53286 13.7598C8.9156 13.3621 12.5704 9.46717 12.5704 6.76548C12.5704 6.72795 12.5704 6.69794 12.5704 6.66792C12.5704 6.6379 12.5704 6.60037 12.5704 6.57036ZM7.99252 8.28893C7.04693 8.28893 6.27395 7.52345 6.27395 6.57036C6.27395 5.61726 7.03943 4.85178 7.99252 4.85178C8.94562 4.85178 9.7111 5.61726 9.7111 6.57036C9.7111 7.52345 8.94562 8.28893 7.99252 8.28893Z\" fill=\"".concat(fill, "\"/>\n  </svg>").trim();
    return "data:image/svg+xml;charset=utf-8,".concat(svg);
};
var AutocompleteUI = /** @class */ (function () {
    function AutocompleteUI(options) {
        if (options === void 0) { options = {}; }
        this.config = Object.assign({}, defaultAutocompleteOptions, options);
        // setup state
        this.isOpen = false;
        this.debouncedFetchResults = this.debounce(this.fetchResults, this.config.debounceMS);
        this.results = [];
        this.highlightedIndex = -1;
        // set threshold alias
        if (this.config.threshold !== undefined) {
            this.config.minCharacters = this.config.threshold;
            Logger.warn('AutocompleteUI option "threshold" is deprecated, use "minCharacters" instead.');
        }
        if (options.near) {
            if (typeof options.near === 'string') {
                this.near = options.near;
            }
            else {
                this.near = "".concat(options.near.latitude, ",").concat(options.near.longitude);
            }
        }
        // get container element
        var containerEL;
        if (typeof this.config.container === 'string') { // lookup container element by ID
            containerEL = document.getElementById(this.config.container);
        }
        else { // use provided element
            containerEL = this.config.container; // HTMLElement
        }
        if (!containerEL) {
            throw new RadarAutocompleteContainerNotFound("Could not find container element: ".concat(this.config.container));
        }
        this.container = containerEL;
        // create wrapper for input and result list
        this.wrapper = document.createElement('div');
        this.wrapper.classList.add(CLASSNAMES.WRAPPER);
        this.wrapper.style.display = this.config.responsive ? 'block' : 'inline-block';
        setWidth(this.wrapper, this.config);
        // result list element
        this.resultsList = document.createElement('ul');
        this.resultsList.classList.add(CLASSNAMES.RESULTS_LIST);
        setHeight(this.resultsList, this.config);
        if (containerEL.nodeName === 'INPUT') {
            // if an <input> element is provided, use that as the inputField,
            // and append the resultList to it's parent container
            this.inputField = containerEL;
            // append to dom
            this.wrapper.appendChild(this.resultsList);
            containerEL.parentNode.appendChild(this.wrapper);
        }
        else {
            // if container is not an input, create new input and append to container
            // create new input
            this.inputField = document.createElement('input');
            this.inputField.classList.add(CLASSNAMES.INPUT);
            this.inputField.placeholder = this.config.placeholder;
            this.inputField.type = 'text';
            this.inputField.disabled = this.config.disabled;
            // search icon
            var searchIcon = document.createElement('div');
            searchIcon.classList.add(CLASSNAMES.SEARCH_ICON);
            // append to DOM
            this.wrapper.appendChild(this.inputField);
            this.wrapper.appendChild(this.resultsList);
            this.wrapper.appendChild(searchIcon);
            this.container.appendChild(this.wrapper);
        }
        // setup event listeners
        this.inputField.addEventListener('input', this.handleInput.bind(this));
        this.inputField.addEventListener('keydown', this.handleKeyboardNavigation.bind(this));
        if (this.config.hideResultsOnBlur) {
            this.inputField.addEventListener('blur', this.close.bind(this), true);
        }
        Logger.debug("AutocompleteUI iniailized with options: ".concat(JSON.stringify(this.config)));
    }
    // create a new AutocompleteUI instance
    AutocompleteUI.createAutocomplete = function (autocompleteOptions) {
        return new AutocompleteUI(autocompleteOptions);
    };
    AutocompleteUI.prototype.handleInput = function () {
        var _this = this;
        // Fetch autocomplete results and display them
        var query = this.inputField.value;
        if (query.length < this.config.minCharacters) {
            return;
        }
        this.debouncedFetchResults(query)
            .then(function (results) {
            var onResults = _this.config.onResults;
            if (onResults) {
                onResults(results);
            }
            _this.displayResults(results);
        })
            .catch(function (error) {
            Logger.warn("Autocomplete ui error: ".concat(error.message));
            var onError = _this.config.onError;
            if (onError) {
                onError(error);
            }
        });
    };
    AutocompleteUI.prototype.debounce = function (fn, delay) {
        var _this = this;
        var timeoutId;
        var resolveFn;
        var rejectFn;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            clearTimeout(timeoutId);
            timeoutId = setTimeout(function () {
                var result = fn.apply(_this, args);
                if (result instanceof Promise) {
                    result
                        .then(function (value) {
                        if (resolveFn) {
                            resolveFn(value);
                        }
                    })
                        .catch(function (error) {
                        if (rejectFn) {
                            rejectFn(error);
                        }
                    });
                }
            }, delay);
            return new Promise(function (resolve, reject) {
                resolveFn = resolve;
                rejectFn = reject;
            });
        };
    };
    AutocompleteUI.prototype.fetchResults = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, limit, layers, countryCode, expandUnits, mailable, onRequest, params, addresses;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.config, limit = _a.limit, layers = _a.layers, countryCode = _a.countryCode, expandUnits = _a.expandUnits, mailable = _a.mailable, onRequest = _a.onRequest;
                        params = {
                            query: query,
                            limit: limit,
                            layers: layers,
                            countryCode: countryCode,
                            expandUnits: expandUnits,
                            mailable: mailable,
                        };
                        if (this.near) {
                            params.near = this.near;
                        }
                        if (onRequest) {
                            onRequest(params);
                        }
                        return [4 /*yield*/, SearchAPI.autocomplete(params)];
                    case 1:
                        addresses = (_b.sent()).addresses;
                        return [2 /*return*/, addresses];
                }
            });
        });
    };
    AutocompleteUI.prototype.displayResults = function (results) {
        var _this = this;
        // Clear the previous results
        this.clearResultsList();
        this.results = results;
        var marker;
        if (this.config.showMarkers) {
            marker = document.createElement('img');
            marker.classList.add(CLASSNAMES.RESULTS_MARKER);
            marker.setAttribute('src', getMarkerIcon(this.config.markerColor));
        }
        // Create and append list items for each result
        results.forEach(function (result, index) {
            var li = document.createElement('li');
            li.classList.add(CLASSNAMES.RESULTS_ITEM);
            // construct result with bolded label
            var listContent;
            if (result.formattedAddress.includes(result.addressLabel) && result.layer !== 'postalCode') {
                // if addressLabel is contained in the formatted address, bold the address label
                var regex = new RegExp("(".concat(result.addressLabel, "),?"));
                listContent = result.formattedAddress.replace(regex, '<b>$1</b>');
            }
            else {
                // otherwise append the address or place label to formatted address
                var label = result.placeLabel || result.addressLabel;
                listContent = "<b>".concat(label, "</b> ").concat(result.formattedAddress);
            }
            li.innerHTML = listContent;
            // prepend marker if enabled
            if (marker) {
                li.prepend(marker.cloneNode());
            }
            // add click handler to each result, use mousedown to fire before blur event
            li.addEventListener('mousedown', function () {
                _this.select(index);
            });
            _this.resultsList.appendChild(li);
        });
        this.open();
        if (results.length > 0) {
            var link = document.createElement('a');
            link.href = 'https://radar.com?ref=powered_by_radar';
            link.target = '_blank';
            this.poweredByLink = link;
            var poweredByText = document.createElement('span');
            poweredByText.textContent = 'Powered by';
            link.appendChild(poweredByText);
            var radarLogo = document.createElement('span');
            radarLogo.id = 'radar-powered-logo';
            link.appendChild(radarLogo);
            var poweredByContainer = document.createElement('div');
            poweredByContainer.classList.add(CLASSNAMES.POWERED_BY_RADAR);
            poweredByContainer.appendChild(link);
            this.resultsList.appendChild(poweredByContainer);
        }
        else {
            var noResultsText = document.createElement('div');
            noResultsText.classList.add(CLASSNAMES.NO_RESULTS);
            noResultsText.textContent = 'No results';
            this.resultsList.appendChild(noResultsText);
        }
    };
    AutocompleteUI.prototype.open = function () {
        if (this.isOpen) {
            return;
        }
        this.wrapper.setAttribute(ARIA.EXPANDED, 'true');
        this.resultsList.removeAttribute('hidden');
        this.isOpen = true;
    };
    AutocompleteUI.prototype.close = function (e) {
        var _this = this;
        if (!this.isOpen) {
            return;
        }
        // run this code async to allow link click to propagate before blur
        // (add 100ms delay if closed from link click)
        var linkClick = e && (e.relatedTarget === this.poweredByLink);
        setTimeout(function () {
            _this.wrapper.removeAttribute(ARIA.EXPANDED);
            _this.resultsList.setAttribute('hidden', '');
            _this.highlightedIndex = -1;
            _this.isOpen = false;
            _this.clearResultsList();
        }, linkClick ? 100 : 0);
    };
    AutocompleteUI.prototype.goTo = function (index) {
        if (!this.isOpen || !this.results.length) {
            return;
        }
        // wrap around
        if (index < 0) {
            index = this.results.length - 1;
        }
        else if (index >= this.results.length) {
            index = 0;
        }
        var resultItems = this.resultsList.getElementsByTagName('li');
        if (this.highlightedIndex > -1) {
            // clear class names on previously highlighted item
            resultItems[this.highlightedIndex].classList.remove(CLASSNAMES.SELECTED_ITEM);
        }
        // add class name to newly highlighted item
        resultItems[index].classList.add(CLASSNAMES.SELECTED_ITEM);
        this.highlightedIndex = index;
    };
    AutocompleteUI.prototype.handleKeyboardNavigation = function (event) {
        // fallback to deprecated "keyCode" if event.code not set
        var code = event.code !== undefined ? event.code : event.keyCode;
        // allow event to propagate if result list is not open
        if (!this.isOpen) {
            return;
        }
        switch (code) {
            // Next item
            case 'Tab':
            case 'ArrowDown':
            case 40:
                event.preventDefault();
                this.goTo(this.highlightedIndex + 1);
                break;
            // Prev item
            case 'ArrowUp':
            case 38:
                event.preventDefault();
                this.goTo(this.highlightedIndex - 1);
                break;
            // Select
            case 'Enter':
            case 13:
                this.select(this.highlightedIndex);
                break;
            // Close
            case 'Esc':
            case 27:
                this.close();
                break;
        }
    };
    AutocompleteUI.prototype.select = function (index) {
        var result = this.results[index];
        if (!result) {
            Logger.warn("No autocomplete result found at index: ".concat(index));
            return;
        }
        var inputValue;
        if (result.formattedAddress.includes(result.addressLabel)) {
            inputValue = result.formattedAddress;
        }
        else {
            var label = result.placeLabel || result.addressLabel;
            inputValue = "".concat(label, ", ").concat(result.formattedAddress);
        }
        this.inputField.value = inputValue;
        var onSelection = this.config.onSelection;
        if (onSelection) {
            onSelection(result);
        }
        // clear results list
        this.close();
    };
    AutocompleteUI.prototype.clearResultsList = function () {
        this.resultsList.innerHTML = '';
        this.results = [];
    };
    // remove elements from DOM
    AutocompleteUI.prototype.remove = function () {
        Logger.debug('AutocompleteUI removed.');
        this.inputField.remove();
        this.resultsList.remove();
        this.wrapper.remove();
    };
    AutocompleteUI.prototype.setNear = function (near) {
        if (near === undefined || near === null) {
            this.near = undefined;
        }
        else if (typeof near === 'string') {
            this.near = near;
        }
        else {
            this.near = "".concat(near.latitude, ",").concat(near.longitude);
        }
        return this;
    };
    AutocompleteUI.prototype.setPlaceholder = function (placeholder) {
        this.config.placeholder = placeholder;
        this.inputField.placeholder = placeholder;
        return this;
    };
    AutocompleteUI.prototype.setDisabled = function (disabled) {
        this.config.disabled = disabled;
        this.inputField.disabled = disabled;
        return this;
    };
    AutocompleteUI.prototype.setResponsive = function (responsive) {
        this.config.responsive = responsive;
        setWidth(this.wrapper, this.config);
        return this;
    };
    AutocompleteUI.prototype.setWidth = function (width) {
        this.config.width = width;
        setWidth(this.wrapper, this.config);
        return this;
    };
    AutocompleteUI.prototype.setMaxHeight = function (height) {
        this.config.maxHeight = height;
        setHeight(this.resultsList, this.config);
        return this;
    };
    AutocompleteUI.prototype.setMinCharacters = function (minCharacters) {
        this.config.minCharacters = minCharacters;
        this.config.threshold = minCharacters;
        return this;
    };
    AutocompleteUI.prototype.setLimit = function (limit) {
        this.config.limit = limit;
        return this;
    };
    AutocompleteUI.prototype.setShowMarkers = function (showMarkers) {
        this.config.showMarkers = showMarkers;
        if (showMarkers) {
            var marker = document.createElement('img');
            marker.classList.add(CLASSNAMES.RESULTS_MARKER);
            marker.setAttribute('src', getMarkerIcon(this.config.markerColor));
            var resultItems = this.resultsList.getElementsByTagName('li');
            for (var i = 0; i < resultItems.length; i++) {
                var currentMarker = resultItems[i].getElementsByClassName(CLASSNAMES.RESULTS_MARKER)[0];
                if (!currentMarker) {
                    resultItems[i].prepend(marker.cloneNode());
                }
            }
        }
        else {
            var resultItems = this.resultsList.getElementsByTagName('li');
            for (var i = 0; i < resultItems.length; i++) {
                var marker = resultItems[i].getElementsByClassName(CLASSNAMES.RESULTS_MARKER)[0];
                if (marker) {
                    marker.remove();
                }
            }
        }
        return this;
    };
    AutocompleteUI.prototype.setMarkerColor = function (color) {
        this.config.markerColor = color;
        var marker = this.resultsList.getElementsByClassName(CLASSNAMES.RESULTS_MARKER);
        for (var i = 0; i < marker.length; i++) {
            marker[i].setAttribute('src', getMarkerIcon(color));
        }
        return this;
    };
    AutocompleteUI.prototype.setHideResultsOnBlur = function (hideResultsOnBlur) {
        this.config.hideResultsOnBlur = hideResultsOnBlur;
        if (hideResultsOnBlur) {
            this.inputField.addEventListener('blur', this.close.bind(this), true);
        }
        else {
            this.inputField.removeEventListener('blur', this.close.bind(this), true);
        }
        return this;
    };
    return AutocompleteUI;
}());

var isSecretKey = function (key) { return (key.includes('_sk_')); };
var isLiveKey = function (key) { return (key.includes('_live_')); };
var Radar = /** @class */ (function () {
    function Radar() {
    }
    Object.defineProperty(Radar, "VERSION", {
        get: function () {
            return SDK_VERSION;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Radar, "ui", {
        // "ui" namespace
        get: function () {
            return {
                maplibregl: MapUI.getMapLibre(),
                map: MapUI.createMap,
                marker: MapUI.createMarker,
                autocomplete: AutocompleteUI.createAutocomplete,
            };
        },
        enumerable: false,
        configurable: true
    });
    Radar.initialize = function (publishableKey, options) {
        if (options === void 0) { options = {}; }
        if (!publishableKey) {
            throw new RadarPublishableKeyError('Publishable key required in initialization.');
        }
        if (isSecretKey(publishableKey)) {
            throw new RadarPublishableKeyError('Secret keys are not allowed. Please use your Radar publishable key.');
        }
        // store settings in global config
        var live = isLiveKey(publishableKey);
        var logLevel = live ? 'error' : 'info';
        var debug = !live;
        var radarOptions = Object.assign(Config.defaultOptions, {
            publishableKey: publishableKey,
            live: live,
            logLevel: logLevel,
            debug: debug,
        }, options);
        Config.setup(radarOptions);
        Logger.info("initialized with ".concat(live ? 'live' : 'test', " publishableKey."));
        if (options.debug) {
            Logger.info("using options: ".concat(JSON.stringify(options)));
        }
        // NOTE(jasonl): this allows us to run jest tests
        // without having to mock the ConfigAPI.getConfig call
        if (!(window === null || window === void 0 ? void 0 : window.RADAR_TEST_ENV)) {
            ConfigAPI.getConfig();
        }
    };
    Radar.clear = function () {
        Config.clear();
    };
    ///////////////////////
    // geofencing platform
    ///////////////////////
    Radar.setUserId = function (userId) {
        if (!userId) {
            Storage.removeItem(Storage.USER_ID);
            return;
        }
        Storage.setItem(Storage.USER_ID, String(userId).trim());
    };
    Radar.setDescription = function (description) {
        if (!description) {
            Storage.removeItem(Storage.DESCRIPTION);
            return;
        }
        Storage.setItem(Storage.DESCRIPTION, String(description).trim());
    };
    Radar.setMetadata = function (metadata) {
        if (!metadata) {
            Storage.removeItem(Storage.METADATA);
            return;
        }
        Storage.setItem(Storage.METADATA, JSON.stringify(metadata));
    };
    Radar.getLocation = function () {
        return Navigator.getCurrentPosition();
    };
    Radar.trackOnce = function (params) {
        if (params === void 0) { params = {}; }
        try {
            return TrackAPI.trackOnce(params);
        }
        finally {
            ConfigAPI.getConfig(params); // call with updated permissions
        }
    };
    Radar.trackVerified = function (params) {
        if (params === void 0) { params = {}; }
        return VerifyAPI.trackVerified(params);
    };
    Radar.getContext = function (params) {
        return ContextAPI.getContext(params);
    };
    Radar.setTripOptions = function (tripOptions) {
        TripsAPI.setTripOptions(tripOptions);
    };
    Radar.clearTripOptions = function () {
        TripsAPI.clearTripOptions();
    };
    Radar.getTripOptions = function () {
        return TripsAPI.getTripOptions();
    };
    Radar.startTrip = function (tripOptions) {
        return TripsAPI.startTrip(tripOptions);
    };
    Radar.updateTrip = function (tripOptions) {
        return TripsAPI.updateTrip(tripOptions);
    };
    Radar.completeTrip = function () {
        return TripsAPI.completeTrip();
    };
    Radar.cancelTrip = function () {
        return TripsAPI.cancelTrip();
    };
    Radar.logConversion = function (params) {
        return ConversionsAPI.logConversion(params);
    };
    /////////////////
    // maps platform
    /////////////////
    Radar.forwardGeocode = function (params) {
        return Geocoding.forwardGeocode(params);
    };
    Radar.reverseGeocode = function (params) {
        return Geocoding.reverseGeocode(params);
    };
    Radar.ipGeocode = function () {
        return Geocoding.ipGeocode();
    };
    Radar.autocomplete = function (params) {
        return SearchAPI.autocomplete(params);
    };
    Radar.searchGeofences = function (params) {
        return SearchAPI.searchGeofences(params);
    };
    Radar.searchPlaces = function (params) {
        return SearchAPI.searchPlaces(params);
    };
    Radar.validateAddress = function (params) {
        return AddressesAPI.validateAddress(params);
    };
    Radar.distance = function (params) {
        return RoutingAPI.distance(params);
    };
    Radar.matrix = function (params) {
        return RoutingAPI.matrix(params);
    };
    return Radar;
}());

export { Radar as default };
//# sourceMappingURL=radar.js.map
